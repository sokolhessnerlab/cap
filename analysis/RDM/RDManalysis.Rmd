---
title: 'CAP: RDM analysis'
author: "Hayley Brooks"
date: "5/13/2021"
output: html_document
---

Data set up is taken care of by RDMsteup.R script. 
```{r setup, include=FALSE}
rm(list=ls())

library('config')
config = config::get()


setup_source = file.path(config$code_files$setup_data)
source(setup_source) #, local = knitr::knit_global())


# Looks for existing model file and if its found, then load it and we will now have our previous models in the environment
modelfile = file.path(config$path$Rdata, config$Rdata_files$models)
if(exists(modelfile)){
  load(modelfile)
}

```

Plot an example choice set for the gain-only task
```{r}
plot(rdmGainQualtrics$rdmAlternative[rdmGainQualtrics$subID==1], col=rdmGainQualtrics$rdmGroundEV, pch=16, xlab="trial", ylab="safe ($)", main="Safe amounts across the task\ncolors = levels")

plot(rdmGainQualtrics$rdmRiskyGain[rdmGainQualtrics$subID==1], col=rdmGainQualtrics$rdmGroundEV, pch=16, xlab="trial", ylab="risky gain ($)", main="Risky gain amounts across the task\ncolors = levels")

plot(rdmGainQualtrics$rdmGroundEV[rdmGainQualtrics$subID==1], col=rdmGainQualtrics$rdmGroundEV, pch=16, xlab="trial", ylab="level or context ($)", main="Context created by shared expected values")


```
 


### Risky decision-making analysis
#### Probability of gambling GAIN ONLY TASK
```{r}
# GROUP LEVEL

Phs1Pgam = mean(rdmGainQualtrics$rdmChoice[rdmGainQualtrics$phase==1], na.rm=T); # phase 1 pgamble = 0.3901198 (n=518)
Phs2Pgam = mean(rdmGainQualtrics$rdmChoice[rdmGainQualtrics$phase==2], na.rm=T); # phase 2 pgamble = 0.3783025 (n=326)
bothPhsPgam = mean(rdmGainQualtrics$rdmChoice[rdmGainQualtrics$subID %in% BothPhsSubIDs], na.rm=T); # pgamble across participants who completed both phase 1 and phase 2 (n=313) = 0.3867135

# 95% CI
# phase 1 (n=518)
me1 = qnorm(.975)*(Phs1Pgam/sqrt(Phs1nSub)); #0.03277965
Phs1Pgam + me1; #0.4134254
Phs1Pgam - me1; #0.3478662

# phase 2 (n=326)
me2 = qnorm(.975)*(Phs2Pgam/sqrt(Phs2nSub)); #0.04032889
Phs2Pgam + me2; #0.4118445
Phs2Pgam - me2; #0.3311867

# phase 1 and phase 2 (n = 313)
me3 = qnorm(.975)*(bothPhsPgam/sqrt(BothPhsnSub)); #0.04192421
bothPhsPgam + me3; #0.4203572
bothPhsPgam - me3; #0.3365088


# INDIVIDUAL LEVEL

# data frame where each row is a participant and there are 6 columns: {subID, day, phase 1 pgam, phase 2 pgam, both phases pgam, diffPgam}. If a participant is not included because they did not complete phase 2 or they were excluded, there will be an NaN in the corresponding  column. "diffPgam" is the difference in probability of gambling between two phases if we have that information for a given participant

pGambleSubID = as.data.frame(matrix(data=NA, nrow =nSubB4exclusion, ncol=6, dimnames=list(c(NULL), c("subID", "day", "phs1pgam","phs2pgam","bothPhspgam", "diffPgam"))))

for (s in 1:nSubB4exclusion) {
  
  
  subPhs1 = rdmGainQualtrics[rdmGainQualtrics$subID==subNumB4exclusion[s] & rdmGainQualtrics$phase==1,rdmColumns];
  subPhs2 = rdmGainQualtrics[rdmGainQualtrics$subID==subNumB4exclusion[s] & rdmGainQualtrics$phase==2,rdmColumns];
  subDay = rdmGainQualtrics$day[rdmGainQualtrics$subID==subNumB4exclusion[s]]
  
  pGambleSubID$subID[s] = subNumB4exclusion[s]
  pGambleSubID$day[s] = subDay[1]
  pGambleSubID$phs1pgam[s] = mean(subPhs1$rdmChoice, na.rm=T)
  pGambleSubID$phs2pgam[s] = mean(subPhs2$rdmChoice, na.rm=T)
  pGambleSubID$bothPhspgam[s] = mean(c(subPhs1$rdmChoice, subPhs2$rdmChoice), na.rm=T)
  pGambleSubID$diffPgam[s] = pGambleSubID$phs2pgam[s] - pGambleSubID$phs1pgam[s]
 
};

# NA bothPhspgam for people who did not participate in phase 2!!

# plot histogram of the change in risk-taking between phases (diff > 0 = more risk taking phase 1; diff < 0 =more risk taking phase 2; diff = 0, similar risk taking across phases)
summary(pGambleSubID$diffPgam); # mean = -.0112 (indicating generally more risk taking in phase 2)
hist(pGambleSubID$diffPgam, main="Distribution of change in risk taking", xlab="change in risk-taking\n p(gamble phase 2) - p(gamble phase 1)", ylab="number of participants",breaks = 100);

par(pty = 's'); # make the figure a square
plot(pGambleSubID$phs1pgam, pGambleSubID$phs2pgam, abline(a=0, b=1), xlab="p(gamble phase 1)", ylab="p(gamble phase 2)", main="Risk-taking in both phases (mean in red)", asp=1, ylim=c(0,1), xlim=c(0,1));
points(mean(pGambleSubID$phs1pgam,na.rm=T), mean(pGambleSubID$phs2pgam,na.rm=T), col="red", pch=17);


```

#### Simple regressions for risky decision-making GAIN ONLY TASK
1) running on lab computer speeds it up a bit, still take a couple minutes.
2) Use glm to explore but very carefully (these take a second)
3) save the R data models (all model names start with "model" except those we don't want saved will start with "tmp")
 - each model has an if statement (using exist function) so that models we already have don't need to be run again


### DOES TASK-RELATED STUFF ACCOUNT FOR RISK-TAKING (main model plus other variations we tried):
```{r}
# Simple, main model that we will take residuals from to do the remaining analyses (has task events only):
if(!exists('model_task')){
  model_task = glmer(rdmChoice~ 1 + rdmGainSC + rdmSafeSC + rdmGroundEV + (0 + rdmGainSC + rdmSafeSC|subID),data=rdmGainQualtrics,family="binomial",na.action=na.exclude, control=glmerControl(optimizer = "bobyqa",optCtrl = list(maxfun=1000000)) );
}
# AIC = 73534.3 - this is not the best AIC but we decided that it probably makes the most sense to keep this model simple (just letting task-related stuff do their things) and then see what else accounts for RDM behavior.




# Other models that we tried for our first-level and aren't going to use for residual analysis but want to save:

# Task events with phase and day:
if(!exists('model_taskPhaseDay')){
  model_taskPhaseDay=glmer(rdmChoice~ 1 + rdmGainSC + rdmSafeSC + rdmGroundEV + phaseRecode + dayOverallSC + (0 + rdmGainSC + rdmSafeSC|subID),data=rdmGainQualtrics,family="binomial", na.action=na.exclude, control=glmerControl(optimizer = "bobyqa",optCtrl = list(maxfun=1000000)) );
}
# AIC = 73516.2
# less risk taking in phase 2
# no effect of day 


# Task events with just phase
if(!exists('model_taskPhase')){
  model_taskPhase=glmer(rdmChoice~ 1 + rdmGainSC + rdmSafeSC + rdmGroundEV + phaseRecode + (0 + rdmGainSC + rdmSafeSC|subID),data=rdmGainQualtrics,family="binomial",na.action=na.exclude, control=glmerControl(optimizer = "bobyqa",optCtrl = list(maxfun=1000000)) );
}
# AIC = 73516.4
# less risk taking in phase 2

```

### Store residuals from our main model (model_task):
```{r}
rdmGainQualtrics$predmTask = predict(model_task, type="link"); 
```

### Models that involve residuals (the bulk of the analysis):

```{r}


# STAIS, STAIT, UCLAL, PSS:
if(!exists('model_pred_stais')){
  model_pred_stais = glmer(rdmChoice~  0 + stai_s_score_scaled + (1|subID), data=rdmGainQualtrics, family="binomial", control=glmerControl(optimizer = "bobyqa",optCtrl = list(maxfun=1000000)), offset=predmTask );
}
# singular
# no effect of stais
# AIC = 68606.6
# nObs = 98951

if(!exists('model_pred_stait')){
  model_pred_stait = glmer(rdmChoice~  0 + stai_t_score_scaled + (1|subID), data=rdmGainQualtrics, family="binomial", control=glmerControl(optimizer = "bobyqa",optCtrl = list(maxfun=1000000)), offset=predmTask  );
}
# no effect of stait
# AIC = 68606.6
# nObs = 98951
# singular

if(!exists('model_pred_uclal')){
  model_pred_uclal = glmer(rdmChoice~  0 + uclal_score_scaled + (1|subID), data=rdmGainQualtrics, family="binomial", control=glmerControl(optimizer = "bobyqa",optCtrl = list(maxfun=1000000)) ,offset=predmTask  );
}
# no effect of uclal
# AIC = 68606.6
# nObs = 98951
# singular


if(!exists('model_pred_pss')){
  model_pred_pss = glmer(rdmChoice~ 0 + pss_score_scaled + (1|subID), data=rdmGainQualtrics, family="binomial", control=glmerControl(optimizer = "bobyqa",optCtrl = list(maxfun=1000000)),offset=predmTask )
}
# no effect of pss
# AIC = 68606.7
# nObs = 98951
# singular


# COVID RISK: LEFT OFF HERE!
m1covidrisk = glmer(rdmChoice~  1 + rdmGainSC + rdmSafeSC + rdmGroundEV + covq_PAB_q1_personalRisk_scaledNoNA  + (0 + rdmGainSC + rdmSafeSC|subID), data=rdmGainQualtrics, family="binomial", na.action=na.exclude, control=glmerControl(optimizer = "bobyqa",optCtrl = list(maxfun=1000000)) ); # adding "na.action = na.exclude" retains original row number which we need when pulling out residuals

# AIC = 73465.6
#                                      Estimate Std. Error z value Pr(>|z|)    
# (Intercept)                          -0.08316    0.04824  -1.724   0.0847 .  
# rdmGainSC                            13.64850    0.59595  22.902  < 2e-16 ***
# rdmSafeSC                           -38.02249    1.10598 -34.379  < 2e-16 ***
# rdmGroundEV                           0.12352    0.02482   4.977 6.46e-07 ***
# covq_PAB_q1_personalRisk_scaledNoNA  -0.62479    0.07379  -8.467  < 2e-16 ***

# covid risk mean: 5.26 phase 1 and 5.04 in phase 2
# covid risk variable is capturing across and within subject stuff, to follow up on this:
# 1) resrict data to one phase and if the pattern holds up, we atleast know that individual differences do matter
# 2) relate changes in risk taking to changes in perceived risk (using a variable that captures the difference in covid risk across phase 1)

# Affective measures... 
# - No observed effects (at this level) for STAIS, STAIT, UCLA-L or PSS
# - covid risk measure predicts less risk -taking
# model w/ covid risk (AIC = 73465.6) outperforms model with phase and day(AIC = 73516.2) and just phase (AIC =73516.4)

# Should we use covid risk as our model moving forward?
# Phase is colinear with a lot of things we care about, basically anything that we expect to change over time in a linear way because pandemic progression was going in one direction (a reason for not including it in the trial-level model - will continue to discuss and think about moving forward). Another thing to keep in mind is being careful about how we talk about this, since phase could just be about repeating the experiment.

# Get and save predicted values (i.e. residuals)
rdmGainQualtrics$predm1cr = predict(m1covidrisk, type="link"); # residuals from covid risk model
rdmGainQualtrics$predm1phs = predict(m1phase, type="link"); # residuals from m1phse

# This will be our main model: Might make more sense to just do: rdmGainSC + rdmSafeSC + rdmGroundEV + (0 + rdmGainSC + rdmSafeSC|subID) for the first model then everything else using the residuals
# with a 1 in the random effects, it could wipe out subject level effects that we are interested in  like affective measures (it wouldn't get rid of trial by trial stuff)
# still save the other models though.


```

Temporal context + RDM - left off here
```{r}

# using the residuals from the covid risk model ('pred1mcr') for now since it was the best fitting model
# add trial scaled to this model
mPotcShiftEarn = glmer(rdmChoice ~ 0 + rdmPOC1sc*rdmEarningSC + posShift +  (1|subID), data=rdmGainQualtrics, family="binomial", offset=predm1cr);
# AIC =  67115.6 
#                         Estimate Std. Error z value Pr(>|z|)    
# rdmPOC1sc               0.194549   0.059275   3.282  0.00103 ** 
# rdmEarningSC           -0.047262   0.025171  -1.878  0.06043 .  
# posShift                0.017172   0.004239   4.051 5.11e-05 ***
# rdmPOC1sc:rdmEarningSC -0.381397   0.116458  -3.275  0.00106 ** 

```

Affective measures
# in set up, create subject level dataframe for affective measures (vs what we already have at the trial-level)
# How do we find what is unique across our qualtrics responses?
# could do a component type of analysis for all of the qualtrics responses (Gillan et al 2016 does something like this)
# we could do this in a variety of ways (across all responses v. across all SES responses)
# Gillan (2016) used a package in R to do it 
# "Try not to get paralyzed by the world of ways to do this stuff - start simple"
# Use QualtricsCombined_subID_scored to start - lets just get the summary and standard deviations 
# then we move toward correllogram / run factor analysis / PCA stuff
```{r}

```

```{r}
# save our models
save(file=modelfile, list=ls(pattern=glob2rx("model*")));  #A version of this will be how we save the output at the end
```

